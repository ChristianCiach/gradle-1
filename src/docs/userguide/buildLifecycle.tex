%!TEX root = master.tex
\chapter{The Build Lifecycle} % (fold)
\label{cha:the_build_lifecycle}

We said in the introduction that the core of Gradle is a language for dependency based programming. In Gradle terms this means that you can define tasks and dependencies between tasks. Gradle guarantees that those tasks are executed in the order of their dependencies and are executed only once. Those tasks form an \href{http://en.wikipedia.org/wiki/Directed_acyclic_graph}{Directed Acyclic Graph}. There are build tools that build up such a DAG as they execute there tasks. Gradle builds the complete DAG before any task is executed. This lies at the heart of Gradle and makes many things possible which would not be possible otherwise. Your build scripts configure this DAG. Therefore they are strictly speaking \emph{build configuration scripts}.    

\section{Build Phases} % (fold)
\label{sec:build_phases}

A Gradle build has three distinct phases.
\begin{description}
	\item[Initialization] Gradle supports single and multi-project builds. During phase Gradle determines which project(s) are going to take part in the build. Also during this phase, Gradle creates Project objects for every project taking part in the build. 
	\item[Configuration] The build scripts of the projects taking part in the build are executed which configures the project objects created during the initialization phase.
	\item[Execution] A subset of the tasks, created and configured during the configuration phase, is executed. The subset is determined by the task name arguments passed to the gradle command.
\end{description}
% section build_phases (end)

\section{Settings File} % (fold)
\label{sec:settings_file}
Beside the build script files, Gradle defines a settings file. The settings file is determined by Gradle via a naming convention. The default name for this file is \emph{gradlesettings}. Later in this chapter we explain, how Gradle looks for a settings file. For a single project build, you put the settings file in the top level directory of your project.

The settings file gets executed during the initialization phase. A multiproject build must have a gradlesettings file in the top level project of the multiproject hierarchy. It is required because in the gradlesettings file it is defined, which projects are taking part in the multi-project build (see chapter \ref{cha:multi_project_builds}). For a single-project build, a gradlesettings file is optional. You might need it for example, to add libraries to your build script classpath (see chapter \ref{cha:organizing_build_logic}).

Let's first do some introspection with a single project build:
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/buildlifecycle/gradlesettings}
\VerbatimInput[frame=single,label=gradlefile]{../../../build/distributions/exploded/samples/userguide/buildlifecycle/gradlefile}
\outputInput{../../../build/tutorial-output/buildlifecycle.out}

For a build script property access and method calls are delegated to a project object. Similarly property access and method calls within the settings file is delegated to a settings object created by Gradle automatically at startup.

The settings API is rather small. Right now we are interested in the following part of the API.
Property 	Meaning
projectPaths 	returns The paths to the projects which should take part in this build additional to the project containing the settings file, which takes always in part in the build. A settings project path is always relative to the directory containing the settings file.
Method 	Arguments 	Meaning
include 	String[] projectPaths 	Adds project paths of projects which should take part in this build, additional to the project containing the settings file, which takes always in part in the build. A settings project path is always relative to the directory containing the settings file.
% section settings_file (end)

\section{Multi-Project Builds} % (fold)
\label{sec:multi_project_builds}
A multi-project build is a build where you build more than one project during a single execution of Gradle. Often one project depends on other project of the same multi-project build. You have to declare the projects taking part in the multiproject build in the settings file. There is much more to say about this in the chapter on this topic (See \ref{cha:multi_project_builds}). 
% section multi_project_builds (end)

\section{Initialization} % (fold)
\label{sec:initialization}
How does Gradle know whether to do a single or multiproject build? In particular as you may not just trigger a multiproject build from the root project, but from project taking part in the build. Gradle supports partial multiproject builds (see Multi-Project Builds).

If you execute Gradle from within a project that has no gradlesettings file, Gradle does the following:
\begin{itemize}
	\item It searches the parent directories for the existence of a gradlesettings file.
	\item If no gradlesettings file is found, the build is executed as a single project build.
    \item If a gradlesettings file is found, Gradle checks if the current project is part of the multiproject hierarchy defined in the found gradlesettings file. If not, the build is executed as a single project build. Otherwise a multiproject build is executed.
\end{itemize}
What is the purpose of this behavior? Somehow Gradle has to find out, whether the project you are into, is a subproject of a multiproject build or not. Of course, if it is a subproject, only the subproject and its dependent projects are build. But Gradle needs to create the build configuration for the whole multiproject build. This is because the build scripts of the parent projects have the possibility to add configuration directives to the build configuration of the current project. And the current project might depend on build artifacts of other subprojects (which then of course are also build) (see chapter \ref{cha:multi_project_builds}).

Via the \texttt{-u} command line option, you can tell Gradle not to look in the parent hierarchy for a gradlesettings file. The current project is build as a single project build.

If the current project contains a gradlesettings file, the \texttt{-u} option has no meaning then. Such a build is always executed as:

\begin{itemize}
	\item a single project build, if the gradlesettings file does not define a multiproject hierarchy
    \item a multiproject build, if the gradlesettings file does define a multiproject hierarchy.
\end{itemize}
Now Gradle creates Project objects for every project taking part in the build. For a single project build this is only one project. For a multi-project build these are the projects specified in Settings object (plus the root project). Each project object has the name as the top level folder of the project it belongs to. The projects form a tree according to there position in the file system. Thus every project except the root project has a parent project and might have child projects. There are or gaps in the project tree. This means every parent folder between a specified project folder and the project root is considered to be a project and is automatically part of the project tree. A project might have a build script but it is not mandatory. We will learn about the reason behind this in the next chapter.
\section{Configuration and Execution of a Single Project Build} % (fold)
\label{sec:configuration_and_execution_of_a_single_project_build}

% section configuration_and_execution_of_a_single_project_build (end)
For a single project build, the workflow of the next phases are pretty simple. The build script is executed against the project object created during the initialization phase. Then Gradle looks for tasks with names equals to those passed as command line arguments. If these task names exist, they are executed in the order you have passed them.
% section initialization (end)

% chapter the_build_lifecycle (end)

