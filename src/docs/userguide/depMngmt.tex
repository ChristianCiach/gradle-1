\chapter{Dependency Management}

We think dependency management is very important for almost every projects. Yet the kind of dependency management you need depends on the complexity of the build and on the nature of your project. Is your project a distribution or a library? Is it part of an enterprise environment, where it is integrated into the build of other projects or not? But there are common requirements shared by any type of project:
\begin{itemize}
\item The version of the jar must be easy to recognize. Sometimes it is in the Manifest file of the jar, often not. And even if, it is rather painful to always look into the Manifest file to learn about the version. Therefore we think that you should only use jars which have there version as part of there file name.
\item It has to be clear which are the first level dependencies and which are transitive ones. There are different ways to achieve this. We will look at this later.
\item Conflicting versions of the same jar have to be detected and resolved or an exception has to be thrown.
\end{itemize}

Why do we think this is necessary? Without a dependency management as described above, your are likely to burn your fingers sooner or later. If it is unclear which version of a jar your are using, this can introduce subtle bugs which are very hard to find. For example in a former project I worked at we were using Hibernate 3.0.4. We had some problems with this version so I've installed on my developer machine 3.0.5. This did not solve the problem but I forgot to roll back to 3.0.4. Weeks later there was an exception on our integration machine which I've tried to reproduce from my IDE but I did not succeed. It took me a while to figure out the reason. Without the version in the jar name it would have been much harder to find.

Transitive dependency management is also very important. And as you will see later, it does not necessarily involve remote repositories and xml descriptor files. Gradle allows you to store your jars in CVS or SVN and still use transitive dependency management. Why is Ttransitive dependency management important? If you don't know which dependencies are first level dependencies and which are transitive you are loosing very soon control over your build. Even Gradle has already 20+ jars. An enterprise project using Spring, Hibernate, etc. easily ends up with 100+ jars. There is no way to memorize where all this jars belong to. If you want to get rid of a first level dependency you can't be sure which other jars your are allowed to remove. Because a dependency of your first level dependency might also be a first level dependency itself. Many dependencies are runtime dependencies. So the compiler won't help you in determining this. The end of the story is, as we have seen very often, nobody dares to remove any jar. The project classpath is a complete mess. In one of my former projects, I've found some ldap related jar in the classpath, which sheer presence, as I've found out after much research, accelerated LDAP access. So removing this jar would not have led to any errors. Gradle offers you to express what are first level and what are transitive dependencies. And it validates this information against the reality of your code by using only the first level dependencies for compiling.

There are a couple of ways to deal with this problem. Some are simple but don't scale that well. Other are more heavyweight but scale better. You have the choice.
Background

Traditionally, Java has offered no support at all for dealing with libraries and versions. There are no standard ways to say that foo-1.0.jar depends on a bar-2.0jar. This has led to proprietary solutions for this problem. The most popular solutions have been introduced by Maven and Ivy. Both approaches rely on descriptor xml files, which contains information about the dependencies of a particular jar. Both also using repositories where the actual jars are placed together with there descriptor files. And both offer resolution for conflicting jar versions in one form or the other. Yet we think the differences of both approaches are significant in terms of flexibility and maintainability. Beside this, Ivy fully supports the Maven dependency handling. So with Ivy you have access to both worlds. We love Ivy. Gradle uses it under the hood for its dependency management. Ivy is most often used via Ant. But it also has a very good API. We integrate deeply with Ivy via its API.

Right now there is a lot of movement in the field of dependency handling. There is OSGi and there is JSR-277. OSGi is available already, JSR-277 is supposed to be shipped with Java 7. These technologies although deal with a painful problem which is neither solved by Maven nor by Ivy. This is enabling different versions of the same jar to be used at runtime.

\section{Simple dependency management}