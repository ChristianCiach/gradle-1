%!TEX root = master.tex
\chapter{The Java Plugin} % (fold)
\label{cha:the_java_plugin}
Table \ref{javalayout} shows the default project layout assumed by the Java Plugin. This is configurable via the convention object. Table \ref{javatasks} shows the tasks added by the Java Plugin. These tasks constitute a lifecycle for Java builds. Table \ref{javaconventionDir} and Table \ref{javaconventionNonDir} shows the most important properties of the convention object of the Java plugin.\footnote{The \emph{buildDir} property is a property of the project object. It defaults to \texttt{build}.} Gradle's conventions contain a convention for the directory hierarchy as well as conventions for the element names of the hierarchy. For example the \texttt{srcDirs} are relative to the \texttt{srcRoot}. Therefore \texttt{srcDirs} is a read-only property. If you want to change the name of the source dirs you need to do this via the \texttt{srcDirNames} property. But the paths you specify here are \emph{relative} to the \texttt{srcRoot}. This has the advantage to make bulk changes easy. If you change \texttt{srcRoot} from \texttt{src} to \texttt{source}, this automatically applies to all directory properties which are relative to \texttt{srcRoot}. As this also introduces an inflexibility, we have additional floating dirs, which are not bound to any hierarchy (see Table \ref{javaconventionFloatingDir}). For example code generation tool could make use of this, by adding a source dir which is located in the build folder.

\begin{table}
	\begin{center}
	\begin{tabular}{|l|l|} \hline
	\textbf{Folder} & \textbf{Meaning} \\ \hline
	\texttt{src/main/java} & Application/Library sources \\ \hline
	\texttt{src/main/resources} & Application/Library resources \\ \hline
	\texttt{src/main/webapp} & Web application sources \\ \hline
	\texttt{src/test/java} & Test sources \\ \hline
	\texttt{src/test/resources} & Test resources \\ \hline
	\end{tabular}
	\end{center}
	\caption{Default Directory Layout}	
	\label{javalayout}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|} \hline
			\textbf{Taskname} & \textbf{dependsOn} & \textbf{Type} \\ \hline
			clean & - & org.gradle.api.tasks.Clean \\ \hline
			javadoc & - & org.gradle.api.tasks.Javadoc \\ \hline
			init & - & org.gradle.api.tasks.DefaultTask \\ \hline
			resources & initialize & org.gradle.api.tasks.Resources \\ \hline
			compile & resources & org.gradle.api.tasks.compile.Compile \\ \hline
			testResources & compile & org.gradle.api.tasks.Resources \\ \hline
			testCompile & testResources & org.gradle.api.tasks.compile.Compile \\ \hline
			test & testCompile & org.gradle.api.tasks.testing.Test \\ \hline
			libs & test & org.gradle.api.tasks.bundling.Bundle \\ \hline
			uploadLibs & libs & org.gradle.api.tasks.Upload \\ \hline
			dists & uploadLibs & org.gradle.api.tasks.bundling.Bundle \\ \hline
			uploadDists & dists & org.gradle.api.tasks.Upload \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Plugin Tasks}	
	\label{javatasks}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|l|} \hline
			\textbf{Dir Name} & \textbf{Dir File} & \textbf{Default Value Name} & \textbf{Default Value File}\\ \hline
			srcRootName & srcRoot & \texttt{src} & \emph{projectDir}\texttt{/src}\\ \hline
			srcDirNames & srcDirs & \texttt{main/java} & [\emph{srcRoot}\texttt{/main/java}] \\ \hline
			resourceDirNames & resourceDirs & \texttt{main/resources} & [\emph{srcRoot}\texttt{/main/resources}]\\ \hline
			testSrcDirNames & testSrcDirs & \texttt{test/java} & [\emph{srcRoot}\texttt{/test/java}] \\ \hline
			testResourceDirNames & testResourceDirs & \texttt{main/resources} & [\emph{srcRoot}\texttt{/main/resources}] \\ \hline
			srcDocsDirName & srcDocsDir & \texttt{docs} & \emph{srcRoot}\texttt{/docs} \\ \hline
			classesDirName & classesDir & \texttt{classes} & \emph{buildDir}\texttt{/classes} \\ \hline
			testClassesDirName & testClassesDir & \texttt{test-classes} & \emph{buildDir}\texttt{/test-classes} \\ \hline
			testResultsDir & testResultsDirName & \texttt{test-results} & \emph{buildDir}\texttt{/test-results} \\ \hline
			distsDirName & distsDir & \texttt{dists} & \emph{buildDir}\texttt{/dists} \\ \hline
			docsDirName & docsDir & \texttt{docs} & \emph{buildDir}\texttt{/docs} \\ \hline
			javadocDirName & javadocDir & \texttt{javadoc} & \emph{buildDir}\texttt{/javadoc} \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Convention Object - Directory Hierarchy Properties}
	\label{javaconventionDir}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|} \hline
			\textbf{Property} & \textbf{Type} & \textbf{Default Value} \\ \hline
			floatingSrcDirs & List & empty \\ \hline
			floatingResourceDirs & List & empty \\ \hline
			floatingTestResourceDirs & List & empty \\ \hline
			floatingTestResourceDirs & List & empty \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Convention Object - Floating Dir Properties}
	\label{javaconventionFloatingDir}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l|l|l|} \hline
			\textbf{Property} & \textbf{Type} & \textbf{Default Value} \\ \hline
			sourceCompatibility & String & \texttt{null} \\ \hline
			targetCompatibility & String & \texttt{null} \\ \hline
			manifest & GradleManifest & empty \\ \hline
			metaInf & List & empty \\ \hline
		\end{tabular}
	\end{center}
	\caption{Java Convention Object - Non Dir Properties}
	\label{javaconventionNonDir}
\end{table}

\section{Init} % (fold)
\label{sec:initialization}
The \texttt{init} task has no default action attached to it. It is meant to be a hook. You can add actions to it or associates your custom tasks with it. The Java Plugin executes this task before any other of its tasks get executed (except \texttt{clean} and \texttt{javadoc} which does not depends on \texttt{init}).
% section initialization (end)

\section{Javadoc} % (fold)
\label{sec:javadoc}
The \texttt{javadoc} task has no default association with any other task. It has no prerequisites on the actions of other tasks, as it operates on the source. It does not provide a fine-grained configuration API yet. If you need this, you have to use for example Ant's javadoc task directly.
\begin{center}
	\begin{tabular}{|l|l|} \hline
		\multicolumn{2}{|c|}{Convention to Property Mapping} \\ \hline
	    \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		srcDirs & srcDirs \\ \hline
		destinationDir & [javadocDir] \\ \hline
	\end{tabular} 
\end{center} 
% section javadoc (end)

\section{Clean} % (fold)
\label{sec:clean}
The \texttt{clean} task simply removes the directory denoted by its \texttt{dir} property. This property is mapped to the \texttt{buildDir} property of the project. In future releases there will be more control of what gets deleted. If you need more control now, you can use the \emph{Ant delete task}.  
% section clean (end)

\section{Resources} % (fold)
\label{sec:resources}
The \emph{Resources} task has two instances, \texttt{resources} and \texttt{testResources}. 
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{Convention to Property Mapping} \\ \hline
		\textbf{Task Instance} & \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		resources & sourceDirs & resourceDirs \\ \hline
		resources & destinationDir & classesDir \\ \hline
		testResources & sourceDirs & testResourceDirs \\ \hline
		testResources & destinationDir & testClassesDir \\ \hline
	\end{tabular} 
\end{center}
\noindent The \texttt{resources} task offers includes and excludes directives as well as filters. Have a look at \href{\API tasks/Resources.html}{org.gradle.api.tasks.Resources} to learn about the details.
% section resources (end)

\section{Compile} % (fold)
\label{sec:compile}
The \emph{Compile} task has two instances, \texttt{compile} and \texttt{testCompile}. 
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{Convention to Property Mapping} \\ \hline
		\textbf{Task Instance} & \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		compile & srcDirs & srcDirs \\ \hline
		compile & destinationDir & classesDir \\ \hline
		compile & sourceCompatibility & sourceCompatibility \\ \hline
		compile & targetCompatibility & targetCompatibility \\ \hline
		testCompile & srcDirs & testSrcDirs \\ \hline
		testCompile & destinationDir & testClassesDir \\ \hline
		testCompile & sourceCompatibility & sourceCompatibility \\ \hline
		testCompile & targetCompatibility & targetCompatibility \\ \hline
	\end{tabular} 
\end{center}
\noindent The classpath of the compile task is derived from two sources. One is the \emph{configuration} assigned to the task by the dependency manager. The other classpath source is the \texttt{unmanagedClasspath} property: a list of files denoting a jar or a directory. Usually you create your classpath with the dependency manager. The \texttt{unmanagedClasspath} is used internally by Gradle. This classpath is not shared between projects in a multi-project build. Nor is it part of a dependency descriptor if you choose to upload your library to a repository. 
See section \ref{} how the JavaPlugin glues the tasks with the dependency manager and see the whole chapter \ref{cha:dependency_management} how to use the dependency manager.

Have a look at \href{}{org.gradle.api.tasks.compile.Compile} to learn about the details. The compile task delegates to Ants javac task to do the compile. Via the compile task you can set most of the properties of Ants javac task. 
% section compile (end)

\section{Test} % (fold)
\label{sec:test}
The \texttt{test} task executes the unit tests which have been compiled by the \texttt{testCompile} task. 
\begin{center}
	\begin{tabular}{|l|l|} \hline
		\multicolumn{2}{|c|}{Convention to Property Mapping} \\ \hline
	    \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		testClassesDir & testClassesDir \\ \hline
		testResultsDir & testResultsDir \\ \hline
		unmanagedClasspath & [classesDir] \\ \hline
	\end{tabular} 
\end{center}
\noindent Have a look at \href{\API tasks/testing/Test.html}{org.gradle.api.tasks.testing.Test} to learn more. Right now the test results are always in XML-format. The task has a \texttt{stopAtFailuresOrErrors} property to control the behavior when tests are failing. The task \emph{always} executes all the tests and afterwards stops the build if this property is true and there are failing tests or tests that have thrown an uncaught exception. The test task delegates to Ants junit task. TestNG is not supported yet. You can expect TestNG support with our next release. 
% section test (end)

\section{Bundles} % (fold)
\label{sec:bundles}
The \emph{Bundle} task has two instances, \texttt{libs} and \texttt{dists}. The Bundle task is a special animal. It is a container for archive tasks (jar, zip, ...).  
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{Convention to Property Mapping} \\ \hline
		\textbf{Task Instance} & \textbf{Task Property} & \textbf{Convention Property} \\ \hline
		libs & tasksBaseName & \texttt{project.name} \\ \hline
		libs & childrenDependOn & ['test'] \\ \hline
		dists & tasksBaseName & \texttt{project.name} \\ \hline
		dists & childrenDependOn & ['libs'] \\ \hline
	\end{tabular} 
\end{center}
\subsection{The libs Task} % (fold)
\label{sub:the_libs_task}
The \texttt{libs} task contains all the archive tasks which constitute the libraries needed to use your project as a library. For example in a multi-project build the archives which are produced by the \texttt{libs} task are available in the classpath of a dependent project. If you upload your project into a repository, those archives are part of the dependency descriptor. If you come from Maven you can have only one library jar per project. With Ivy you can have as many as you want. 
The Java plugin adds by default one jar archive to the \texttt{libs} task. This jar contains the content of the \texttt{classesDir}. This is the behavior your are used from Maven. If you are happy with that you usually don't have to touch this task. Except if you want to change the names of the produced archives. 

The \texttt{libs} task depends on the \texttt{test} task and its archive tasks. The archive tasks assigned to the \texttt{libs} task depend by default on the \texttt{test} task as well. You can change this via the \texttt{childrenDependsOn} property of the \texttt{libs} task. 
% subsection the_libs_task (end)
\subsection{The dists Task} % (fold)
\label{sub:the_dists_task}
The \texttt{dists} task contains all the archive task that make up your distributions. For example a binary and a source distribution. The \texttt{dists} task has two purposes. One is providing a hook for distributions in the lifecycle. The other is for collection distribution archives for uploading (the same is also true for the \texttt{libs} task.) The \texttt{dists} task depends on its archive tasks and the \texttt{libs} task. The contained archive tasks depend by default on the \texttt{libs} task as well.
% subsection the_dis (end)
\subsection{Example} % (fold)
\label{sub:example}
\begin{Verbatim}
dists {
	dists {
	    tasksBaseName = 'gradle'
	    dependsOn 'explodedDist'
	    childrenDependOn << 'explodedDist'
	    zip() {
	        zipFileSet(dir: explodedDistDir, prefix: "gradle-$version") {
	            exclude '**/*.tmp'
	        }
	    }
	    zip("gradle-src") {
	        String prefix = "$gradle-src-$version"
	        zipFileSet(dir: projectDir, prefix: prefix) {
	            include 'src/', 'gradle.groovy'
	        }
	    }
	}
}	
\end{Verbatim}
The Bundle task has a couple of convenience methods for adding new archive tasks to it. Right now there are the methods (\texttt{jar}, \texttt{war}, \texttt{zip}, \texttt{tar}, \texttt{tarGz}, \texttt{tarBzip2}). Calling such a method with no arguments (e.g. \texttt{zip()}) creates a zip archive task with:
\begin{itemize}
	\item a name: \texttt{tasksBaseName} plus the \_TYPE suffix (e.g. gradle\_zip).
	\item a resulting archive name: \texttt{tasksBaseName} plus version plus the \_TYPE suffix (e.g. gradle-1.0.zip).
\end{itemize}
You can pass two (optional) arguments to those methods. One is a name which replaces the \texttt{tasksBaseName} value for this archive task. The other is a closure for configuring the archive task (e.g. defining the files of the archive).
The default value for \texttt{tasksBaseName} is the project name. So usually you don't need to set it explicitly. 
% subsection examples (end)  

\section{Archive Tasks} % (fold)
\label{sec:archive_tasks}
An archive task is a task which produces an archive at execution time. The following archives tasks are available:
\begin{center}
	\begin{tabular}{|l|l|} \hline
		Type & Accepted file container \\ \hline
		\href{\API tasks/bundling/Zip.html}{org.gradle.api.tasks.bundling.Zip} & fileSet, fileCollection, zipFileSet \\ \hline
		\href{\API tasks/bundling/Tar.html}{org.gradle.api.tasks.bundling.Tar} & fileSet, fileCollection, zipFileSet \\ \hline
		\href{\API tasks/bundling/Jar.html}{org.gradle.api.tasks.bundling.Jar} & fileSet, fileCollection \\ \hline
		\href{\API tasks/bundling/War.html}{org.gradle.api.tasks.bundling.War} & fileSet, fileCollection \\ \hline		
	\end{tabular}
\end{center}
The following file containers are available:
\begin{center}
	\begin{tabularx}{\textwidth}{|l|X|} \hline
		Type & Meaning \\ \hline
		\href{\API tasks/util/FileSet.html}{org.gradle.api.tasks.util.FileSet} & A set of files defined by a common baseDir and include/exclude patterns. \\ \hline
		\href{\API tasks/util/ZipFileSet.html}{org.gradle.api.tasks.util.ZipFileSet} & Extends FileSet with additional properties known from Ants zipfileset task.\\ \hline
		\href{\API tasks/util/FileCollection.html}{org.gradle.api.tasks.util.FileCollection} & An arbitrary collection of files to the archive. In contrast to a FileSet they don't need to have a common basedir.\\ \hline		
	\end{tabularx}
\end{center}
% section archive_tasks (end)

\section{Upload} % (fold)
\label{sec:upload}
The \emph{Upload} task has two instances, \texttt{uploadLibs} and \texttt{uploadDists}. An easy way of describing there behavior, is that all archives added to the \texttt{libs} and \texttt{dists} bundle are uploaded by the corresponding upload task. An upload task uploads to the repositories assigned to it. If needed you have more control on what files get uploaded. Have a look at \href{\API tasks/Upload.html}{org.gradle.api.tasks.Upload} to learn more.
% section upload (end)

\section{Manifest} % (fold)
\label{sec:manifest}
The convention object of the JavaPlugin has a \texttt{manifest} property pointing to an instance of \href{\API tasks/bundling/GradleManifest.html}{org.gradle.api.bundling.GradleManifest}. With this \texttt{GradleManifest} object you can define the content of the \texttt{MANIFEST.MF} file of a jar or a war archive. 
\begin{Verbatim}
manifest.mainAttributes(Implementation-Title: "Gradle", Implementation-Version: $version)
\end{Verbatim}
You can also define sections of a manifest file.
% section manifest (end)

\section{MetaInf} % (fold)
\label{sec:metainf}
The convention object of the JavaPlugin has a \texttt{metaInf} property pointing to a list file containers as described in section \ref{sec:archive_tasks}. With this file containers you can define which files should be in the META-INF directory of a jar or a war archive. 
\begin{Verbatim}
metaInf << new FileSet(someDir)
\end{Verbatim}
% section metainf_and_manifest (end)
% chapter the_java_plugin (end)
