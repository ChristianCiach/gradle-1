%!TEX root = userguide.tex
\chapter{Plugins} % (fold)
\label{cha:plugins}
Now we look at \emph{how} Gradle provides build-by-convention and out of the box functionality. These features are decoupled from the core of Gradle. Gradle provides them via plugins. To make this clear at the very beginning. The plugins provided by Gradle belong to the core distribution of Gradle and they are NEVER updated or changed in any way for a particular Gradle distribution. If there is a bug in the compile functionality of Gradle, we gonna release a new version of Gradle. There is no change of behavior for the lifetime of a given distribution of Gradle. We mention this as there is another build tools with a plugin system which behaves differently. 

\section{Declaring Plugins} % (fold)
\label{sec:using_plugins}
If you want to use the plugin for building a Java project, simply type
\begin{Verbatim}
usePlugin('java')	
\end{Verbatim}
at the beginning of your script. That's all. From a technological point of view plugins use just the same operations as you can use from your build scripts. That is they use the Project and Task API (see chapter \ref{cha:the_project_and_task_api}). The Gradle plugins use this API for:
\begin{itemize}
	\item Adding tasks to your build (e.g. compile, test)
    \item Creating dependencies between those tasks to let them execute in the appropriate order.
    \item Adding a so called \emph{convention object} to your project configuration.
\end{itemize}
Let's check this out:
\codeInput{../../samples/userguide/tutorial/pluginIntro/build.gradle}
\outputInputTutorial{pluginIntro}
The JavaPlugin adds a \texttt{compile} task to the project object which can be accessed by a build script.

\noindent The usePlugin method either takes a string or a class as an argument. You can write\footnote{Thanks to Gradles default imports (see \ref{cha:ide_support}) you can also write \texttt{usePlugin(JavaPlugin)} in this case.}
\begin{Verbatim}
usePlugin(org.gradle.api.plugins.JavaPlugin)
\end{Verbatim} 
Any class, which implements the Plugin interface, can be used as a plugin. Just pass the class as an argument. You don't need to configure anything else for this. If you want to access a custom plugin via a string identifier, you must inform Gradle about the mapping. You can do this in the file \texttt{plugin.properties} in the top level directory of Gradle. It looks like this for the current release:
\codeInput{../../toplevel/plugin.properties}
If you want to use your own plugins, you must make sure that they are accessible via the build script classpath. See chapter \ref{cha:organizing_build_logic} for more information.
% section using_plugins (end)

\section{Configuration} % (fold)
\label{sec:configuration}
If you use the \emph{JavaPlugin} there is for example a compile and resources task for your production code (the same is true for your test code). The default location for the output of those task is the directory \texttt{build/classes}. What if you want to change this? Let's try:
\codeInput{../../samples/userguide/tutorial/pluginConfig/build.gradle}
\outputInputTutorial{pluginConfig}
Setting the \texttt{destinationDir} of the resources task had only an effect on the resources task. Maybe this was what you wanted. But what if you want to change the output directory for all tasks? It would be unfortunate if you had to do this for each task separately. 

Gradles tasks are usually \emph{convention aware}. A plugin can add a convention object to your build. It can also map certain values of this convention object to task properties.
\codeInput{../../samples/userguide/tutorial/pluginConvention/build.gradle}
\outputInputTutorial{pluginConvention}
The \emph{JavaPlugin} has added a convention object with a \texttt{classesDirName} property. The properties of a convention object can be accessed like project properties. As shown in the example, you can also access the convention object explicitly.

By setting a task attribute explicitly (as we have done in the first example) you overwrite the convention value for this particular task.

Not all of the tasks attributes are mapped to convention object values. It is the decision of the plugin to decide what are the shared properties and then bundle them in a convention object and map them to the tasks.

\subsection{More about convention objects} % (fold)
\label{sub:more_about_convention_objects}
Every project object has a convention object which is a container for convention objects contributed by the plugins declared for your project. If you simply access or set a property or access a method in your build script, the project object first looks if this is a property of itself. If not, it delegates the request to its convention object. The convention object checks if any of the plugin convention objects can fulfill the request (first wins and the order is not defined). The plugin convention objects also introduce a namespace.   
\begin{Verbatim}
usePlugin('java')
println classesDir
println convention.classesDir
println convention.plugins.java.classesDir
\end{Verbatim}   
All three statements print out the same property. The more specific statements are useful if there are ambiguities.  
% subsection more_about_convention_objects (end)

\subsection{Declaring Plugins Multiple Times} % (fold)
\label{sub:declaring_plugins_multiple_times}
A plugin is only called once for a given project, even if you have multiple \texttt{usePlugin()} statements. An additional call after the first call has no effect but doesn't hurt either. This can be important if you use plugins which extends other plugins. For example \texttt{usePlugin('groovy')} calls also the Java Plugin. We say the Groovy plugin extend the Java plugin. But you might as well write:
\begin{Verbatim}
usePlugin('java')
usePlugin('groovy')
\end{Verbatim}
If you use cross-project configuration in multi-project builds this is a useful feature.
% subsection declaring_plugins_multiple_times (end)

% section configuration (end)
\section{Summary} % (fold)
\label{sec:summary}
Plugins provide tasks, which are glued together via dependsOn relations and a convention object. 
% section summary (end)
% chapter plugins (end)