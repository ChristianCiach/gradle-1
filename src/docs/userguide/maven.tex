%!TEX root = userguide.tex
\chapter{Interacting with Maven Repositories} % (fold)
\label{cha:interacting_with_maven_repositories}
\section{Introduction} % (fold)
\label{sec:introduction}
With Gradle you can deploy to remote Maven repositories or install to your local Maven repository. This includes all Maven metadata manipulation and works also for Maven snapshots. In fact, Gradles deployment is 100 percent Maven compatible as we use the native Maven Ant tasks under the hood.

Deploying to a Maven repository is only half the fun if you don't have a pom. Fortunately Gradle can generate this pom for your, from the dependency information it has. 
% section introduction (end)

\section{Deploying to a Maven Repository} % (fold)
\label{sec:deploying_to_a_maven_repository}
Let's assume your projects libs bundle produces just one jar file. Now you want to deploy this jar file to a remote Maven repository.
\begin{Verbatim}
uploadLibs {
    uploadResolvers.addMavenDeployer('maven-deployer') {
        repository(url: "file://localhost/tmp/myRepo/")
    }
}
\end{Verbatim}
That is all. Calling the \texttt{uploadLibs} task will generate the pom and deploys the artifact and the pom to the specified repository. 

There is some more work to do, if you need support for other protocols than \texttt{file}. In this case the native Maven code we delegate to needs additional libraries. Those libraries depend on the protocol you need. The available protocols and the corresponding libraries are listed in table \ref{wagonLibs}. Those libraries have again transitive dependencies which have transitive dependencies. You need to provide the complete list of those to the MavenDeployer{\footnote{It is planned for a future release to provide out-of-the-box support for this}}. The easiest way to do this is the following:
\begin{Verbatim}
dependencies {
    addConfiguration('deployerJars')
	addMavenRepo()
	deployerJars "org.apache.maven.wagon:wagon-ssh:1.0-beta-2"
}
uploadLibs {
    uploadResolvers.addMavenDeployer('maven-deployer') {
        repository(url: "scp://repos.mycompany.com/releases")
        addProtocolProviderJars(dependencies.resolve('deployerJars'))
    }
}
\end{Verbatim}

\begin{table}
	\begin{center}
	\begin{tabular}{|l|l|} \hline
	\textbf{Protocol} & \textbf{Library} \\ \hline
	http & org.apache.maven.wagon:wagon-http:1.0-beta-2 \\ \hline
	ssh & org.apache.maven.wagon:wagon-ssh:1.0-beta-2 \\ \hline
	ssh-external & org.apache.maven.wagon:wagon-ssh-external:1.0-beta-2 \\ \hline
	scp & org.apache.maven.wagon:wagon-scp:1.0-beta-2 \\ \hline
	ftp & org.apache.maven.wagon:wagon-ftp:1.0-beta-2 \\ \hline
	webdav & org.apache.maven.wagon:wagon-webdav:1.0-beta-2 \\ \hline
	file & - \\ \hline
	\end{tabular}
	\end{center}
	\caption{Protocol jars for Maven deployment}	
	\label{wagonLibs}
\end{table}
\subsection{Configuration of the Maven Deployer} % (fold)
\label{sub:configuration_of_the_maven_deployer}
There are many configuration options for the Maven deployer. The configuration is done with a nested tree. Here is a configuration with all existing elements of this tree. Table \ref{deployerConfig} lists the available elements and a link to the javadoc of the corresponding class. In the javadoc you can see the possible attributes you can set for a particular element.
\begin{Verbatim}
uploadLibs {
    uploadResolvers.addMavenDeployer('maven-deployer') {
        uniqueVersion = true
        repository(url: "ssh://localhost/tmp/myRepo/") {
			authentication(userName: "me", password: "myPassword")
			releases()
			snapshots()
			proxy()
        }
		snapshotRepository(url: "ssh://localhost/tmp/mySnapshotRepo/") {
			authentication(userName: "me", password: "myPassword")
			releases()
			snapshots()
			proxy()
        }
    }
}
\end{Verbatim}
In Maven you can define repositories and optionally snapshot repositories. If not snapshot repository is defined releases and snapshots are both deployer to the \texttt{repository} element. Otherwise snapshots are deployed to the \texttt{snapshotRepository} element.

\begin{table}
	\begin{center}
	\begin{tabular}{|l|l|} \hline
	\textbf{Element} & \textbf{Javadoc} \\ \hline
	root & \href{\API dependencies/maven/MavenDeployer.html}{org.gradle.dependencies.maven.MavenDeployer} \\ \hline
	repository & \href{http://maven.apache.org/ant-tasks/apidocs/org/apache/maven/artifact/ant/RemoteRepository.html}{org.apache.maven.artifact.ant.RemoteRepository} \\ \hline
	authentication & \href{http://maven.apache.org/ant-tasks/apidocs/org/apache/maven/artifact/ant/Authentication.html}{org.apache.maven.artifact.ant.Authentication} \\ \hline
	releases & \href{http://maven.apache.org/ant-tasks/apidocs/org/apache/maven/artifact/ant/RepositoryPolicy.html}{org.apache.maven.artifact.ant.RepositoryPolicy} \\ \hline
	snapshots & \href{http://maven.apache.org/ant-tasks/apidocs/org/apache/maven/artifact/ant/RepositoryPolicy.html}{org.apache.maven.artifact.ant.RepositoryPolicy} \\ \hline
	proxy & \href{http://maven.apache.org/ant-tasks/apidocs/org/apache/maven/artifact/ant/Proxy.html}{org.apache.maven.artifact.ant.Proxy} \\ \hline
	snapshotRepository & \href{http://maven.apache.org/ant-tasks/apidocs/org/apache/maven/artifact/ant/RemoteRepository.html}{org.apache.maven.artifact.ant.RemoteRepository} \\ \hline
	\end{tabular}
	\end{center}
	\caption{Configuration elements of the MavenDeployer}	
	\label{deployerConfig}
\end{table}
% subsection configuration_of_the_maven_deployer (end)
% section deploying_to_a_maven_repository (end)

\subsection{Installing to the local repository} % (fold)
\label{sub:installing_to_the_local_repository}
The easiest way to install to the local Maven repository is by using the maven plugin:
\begin{Verbatim}
usePlugin('maven')
\end{Verbatim}
This plugin adds an \texttt{install} task. This install task depends on the \texttt{libs} task of the Java plugin. It installs your libraries to your local Maven repository. If the default location for the local repository is redefined in a Maven \texttt{settings.xml}, this is considered by this task.
% subsection installing_to_the_local_repository (end)

\section{Maven Pom Generation} % (fold)
\label{sec:maven_pom_generation}
The Maven Poms are automatically generated by Gradle. You can find the generated poms in the \texttt{<buildDir>/lib-poms} and \texttt{<buildDir>/dist-poms} directory. In many scenarios it just works and you don't have to do anything. But there are situations were you want or have to customize the pom generation.
\subsection{Changing non-dependency elements of the pom} % (fold)
\label{sub:changing_non_dependency_elements_of_the_pom}
You might want that the artifact deployed to the maven repository has a different version or name than the artifact generated by Gradle. In such a case you can apply custom settings.
\begin{Verbatim}
uploadLibs {
    uploadResolvers.addMavenDeployer('maven-deployer') {
        repository(url: "file://localhost/tmp/myRepo/")
        pom.version = '1.0Maven'
        pom.artifactId = 'myName'
    }
}
\end{Verbatim}
To learn about all the customizable attributes of a pom have a look here: \href{\API dependencies/maven/MavenPom.html}{org.gradle.dependencies.maven.MavenPom}.

To do this for the Maven Installer added by the Maven plugin (see \ref{sub:installing_to_the_local_repository}), you can do:
\begin{Verbatim}
install {
    configure(uploadResolvers.get('maven-installer')) {
        pom.version = '1.0Maven'
        pom.artifactId = 'myName'
    }
}
\end{Verbatim}
\subsection{Multiple Artifacts per project} % (fold)
\label{sub:multiple_artifacts_per_project}
Maven can only deal with one artifact per project. This is also reflected in the structure of the Maven pom. We think there are many situations where it makes sense to have more than one artifact per project. Obviously just for the fact that those artifacts have different names but belong to the same group, they need different poms. Another use case is that you might not want to publish all project artifacts to the Maven Repository but only a subset. If your project libs or dists have more than one artifact you have to assign each artifact you want to publish. The MavenDeployer and the MavenInstaller both provide an API for this:
\begin{Verbatim}
uploadLibs {
    uploadResolvers.addMavenDeployer('maven-deployer') {
        repository(url: "file://localhost/tmp/myRepo/")
        addFilter('api') { artifact, file ->
			artifact.name == 'api'
		}
		addFilter('service') { artifact, file ->
			artifact.name == 'service'
		}
		pom('api').version = 'mySpecialMavenVersion'
    }
}
\end{Verbatim}
To learn more about this have a look at \href{\API dependencies/maven/GroovyPomFilterContainer.html}{org.gradle.dependencies.maven.GroovyPomFilterContainer} and its associated classes.
% subsection multiple_artifacts_per_project (end)
\subsection{Dependency Mapping} % (fold)
\label{sub:dependency_mapping}
The Java plugin configures the a default mapping between Gradle configuration and Maven scopes. Most of the time you don't need to touch this and you can safely skip this section. A Gradle-Maven dependency mapping is not trivial, as in Gradle dependencies can belong to more than one configuration. Our mapping works like the following. You can map a configuration to one and only one scope. Different configurations can be mapped to more than one scope. One can assign also a priority to a particular configuration-to-scope mapping. The default mapping is accessible via the dependency manager like \texttt{dependencies.defaultMavenScopeMapping}. Have a look at the javadoc of \href{\API dependencies/maven/Conf2ScopeMappingContainer.html}{org.gradle.dependencies.maven.Conf2ScopeMappingContainer} to learn how you can use the returned instance. Let's look at different mapping scenarios:

\begin{itemize}
	\item A dependency belongs to only one configuration: The first thing Gradle checks is whether there is a mapping for this configuration. If there is none, the dependency is by default not added to the pom. By setting the  mapping property \texttt{includeUnmappedConfigurations} to true, such a dependency will be added. If the configuration is mapped, the corresponding scope is obvious and the dependency is added.
	\item A dependency belongs to more than one mapped configuration: If the mapped configurations map to the same scope the situation is clear. If the mapped configurations map to different scopes the configuration mapping with the highest priority is chosen. If there is more than one configuration with a highest priority and they map to different scopes an exception is thrown.
\end{itemize}
Gradle exclude rules are converted to Maven excludes if possible. Such a conversion is possible if in the Gradle exlude rule the organisation as well as the module name is specified (as Maven needs both in contrast to Ivy). Right now Global Excludes are not converted to the Maven Pom. 

\subsection{Planned future features} % (fold)
\label{sub:planned_future_features}
We plan support for conversion of global excludes. We also plan support for the new Ivy \emph{override} element, which corresponds to the \emph{dependencyManagement} element of a Maven pom. Last but not least we want to make the customization more powerful, by enabling to add custom dependency elements to the pom and remove/modify auto-generated ones.
% subsection planned_future_features (end)
% subsection dependency_mapping (end)
% subsection changing_non_dependency_elements_of_the_pom (end)
% section maven_pom_generation (end)
% chapter interacting_with_maven_repositories (end)