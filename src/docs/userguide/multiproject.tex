%!TEX root = master.tex
\chapter{Multi-project builds} % (fold)
\label{cha:multi_project_builds}

The powerful support for multi-project builds is one of Gradles unique selling points. This topic is also the intellectually most challenging.
\section{Cross Project Configuration} % (fold)
\label{sec:cross_project_configuration}
Let's start with a very simple multi-project build. After all Gradle is a general purpose build tool at its core. So the projects don't have to be java projects. Our first examples are about marine life. 

\subsection{Defining Common Behavior} % (fold)
\label{sub:defining_common_behavior}
We have the following project tree\footnote{F means File and D means Directory}. This is a multi-project build with a root project \texttt{water} and a subproject \texttt{bluewhale}.

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/firstExample/water/gradlesettings}
\end{minipage}
\\

\noindent And where is the build script for the bluewhale project? In Gradle build scripts are optional. Obviously for a single project build, a project without a build script doesn't make much sense. For multiproject builds the situation is different. Let's look at the build script for the water project and execute it.:
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/firstExample/water/gradlefile}
\outputInputGradle[userguide/multiproject/firstExample/water]{../../../build/tutorial-output/multiprojectFirstExample.out}
Gradle allows you to access any project of the multi-project build from any build script. The Project API provides a method called project, which takes a path as an argument and returns the project object for this path. The capability to configure a project build from any build script we call \emph{Cross Project Configuration}. Gradle implements this via \emph{Configuration Injection}.

We are not that happy with the build script of the water project. It is inconvenient to add the task explicitly for every project. We can do better. Let's first add another project called \emph{krill} to our multi-project build.

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
  D- krill	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/addKrill/water/gradlesettings}
\end{minipage}
\\

\noindent Now we rewrite the water build script and boil it down to a single line.
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/addKrill/water/gradlefile}
\outputInputGradle[userguide/multiproject/addKrill/water]{../../../build/tutorial-output/multiprojectAddKrill.out}
Is this cool or is this cool? And how does this work? The Project API provides a property \texttt{allprojects} which returns a list with the current project and all its subprojects underneath it. If you call \texttt{allprojects} with a closure, the statements of the closure are delegated to the projects associated with \texttt{allprojects}. You could also do an iteration via \texttt{allprojects.each}, but that would be more verbose.
\\

\begin{graybox}
Other build systems use inheritance as the primary means for defining common behavior. We also offer inheritance for projects as you will see later. But Gradle uses \texttt{Configuration Injection} as the usual way of defining common behavior. We think it provides a very powerful and flexible way of configuring multiproject builds.	
\end{graybox}
% subsection defining_common_behavior (end)
% section cross_project_configuration (end)

\section{Subproject Configuration} % (fold)
\label{sec:subproject_configuration}
\noindent The Project API also provides a property for accessing the subprojects only. 

\subsection{Defining Common Behavior} % (fold)
\label{sub:defining_common_behavior}
\codeGradleFile{../../../build/distributions/exploded/samples/userguide/multiproject/useSubprojects/water/gradlefile}
\outputInputGradle[userguide/multiproject/useSubprojects/water]{../../../build/tutorial-output/multiprojectUseSubprojects.out}
% subsection defining_common_behavior (end)

\subsection{Adding Specific Behavior} % (fold)
\label{sub:adding_specific_behavior}
You can add specific behavior on top of the common behavior. Usually we put the project specific behavior in the build script of the project where we want to apply this specific behavior. But as we have already seen, we don't have to do it this way. We could add project specific behavior for the bluewhale project like this:

\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/subProjectsAddFromTop/water/gradlefile}
\outputInputGradle[userguide/multiproject/subProjectsAddFromTop/water]{../../../build/tutorial-output/multiprojectSubProjectsAddFromTop.out}
As we have said, we usually prefer to put project specific behavior into the build script of this project. Let's refactor and also add some project specific behavior to the krill project.
\\

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
    F- gradlefile
  D- krill
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/gradlesettings}
\end{minipage}

\codeGradleFile[bluewhale - ]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/bluewhale/gradlefile}
\codeGradleFile[krill - ]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/krill/gradlefile}
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/gradlefile}
\outputInputGradle[userguide/multiproject/spreadSpecifics/water]{../../../build/tutorial-output/multiprojectSpreadSpecifics.out}
% subsection adding_specific_behavior (end)
\subsection{Project Filtering} % (fold)
\label{sub:project_filtering}
To show more of the power of \emph{Configuration Injection}, lets' add another project called tropicalFish and add more behavior to the build via the build script of the water project.

\subsubsection{Filtering By Name} % (fold)
\label{ssub:filtering_by_name}
\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
    F- gradlefile
  D- krill
    F- gradlefile
  D- tropicalFish	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/addTropical/water/gradlesettings}
\end{minipage}

\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/addTropical/water/gradlefile}
\outputInputGradle[userguide/multiproject/addTropical/water]{../../../build/tutorial-output/multiprojectAddTropical.out}
% subsubsection filtering_by_name (end)
\subsubsection{Filtering By Properties} % (fold)
\label{ssub:filtering_by_properties}

Using the projectname for filtering is one option. Using dynamic project properties is another.
\\

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
    F- gradlefile
  D- krill
    F- gradlefile
  D- tropicalFish
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/gradlesettings}
\end{minipage}

\codeGradleFile[bluewhale - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/bluewhale/gradlefile}
\codeGradleFile[krill - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/krill/gradlefile}
\codeGradleFile[tropicalFish - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/tropicalFish/gradlefile}
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/gradlefile}
\outputInputGradle[userguide/multiproject/tropicalWithProperties/water]{../../../build/tutorial-output/multiprojectTropicalWithProperties.out}
In the \texttt{gradefile} of the \texttt{water} project we use \texttt{lateInitialize}. This means that the closure we are passing get evaluated \texttt{after} the build scripts of the subproject are evaluated. As the property \texttt{arctic} is set in those build scripts, we have to do it this way. You will find more on this topic in section \ref{sec:dependencies_which_dependencies}
% subsubsection filtering_by_properties (end)
% subsection project_filtering (end)
% section subproject_configuration (end)

\section{Execution rules for multi-project builds} % (fold)
\label{sec:execution_rules_for_multi_project_builds}
When we have executed the \texttt{hello} task from the root project dir things behaved in an intuitive way. All the \texttt{hello} tasks of the different projects were executed. Let's switch to the \texttt{bluewhale} dir and see what happens if we execute Gradle from there. 
\outputInputGradle[current dir: userguide/multiproject/partialTasks/water/bluewhale]{../../../build/tutorial-output/multiprojectSubBuild.out}
The basic rule behind Gradles behavior is simple. Gradle looks down the hierarchy, starting with the \emph{current dir}, for tasks with the name \texttt{hello} an executes them. One thing is very important to note. Gradle \emph{always} evaluates \emph{every} project of the multi-project build and creates all existing task objects. Then, according to the task name arguments and the current dir, Gradle filters the tasks which should be executed. Because of Gradles \emph{Cross Project Configuration} \emph{every} project has to be evaluated before \emph{any} task gets executed. We will have a closer look at this in the next section. Let's now have our last marine example. Let's add a task to \texttt{bluewhale} and \texttt{krill}.
\codeGradleFile[bluewhale - ]{../../../build/distributions/exploded/samples/userguide/multiproject/partialTasks/water/bluewhale/gradlefile}
\codeGradleFile[krill - ]{../../../build/distributions/exploded/samples/userguide/multiproject/partialTasks/water/krill/gradlefile}
\outputInputGradle[userguide/multiproject/partialTasks/water]{../../../build/tutorial-output/multiprojectPartialTasks.out}
Here the output without the \texttt{-q} option
\outputInputGradle[userguide/multiproject/partialTasks/water]{../../../build/tutorial-output/multiprojectPartialTasksNotQuiet.out}
The build is executed from the \texttt{water} project. Neither \texttt{water} nor \texttt{tropicalFish} have a task with the name \texttt{distanceToIceberg}. Gradle does not care. The simple rule mentioned already above is: Execute all tasks down the hierarchy which have this name. Only complain if there is \emph{no} such task!
% section execution_rules_for_multi_project_builds (end)

\section{Project and Task Paths} % (fold)
\label{sec:project_and_task_paths}
A project path has the following pattern: It starts always with a colon, which denotes the root project. The root project is the only project in a path that is not specified by its name. The path \texttt{:bluewhale} corresponds to the file system path \texttt{water/project} in the case of the example above.

The path of a task is simply its project path plus the task name. For example \texttt{:bluewhale:hello}. Within a project you can address a task of the same project just by its name. This is interpreted as a relative path.

Originally Gradle has used the \texttt{'/'} character as a natural path separator. With the introduction of directory tasks (see \ref{sec:directory_creation}) this was no longer possible, as the name of the directory task contains the \texttt{'/'} character.
% section project_and_task_paths (end)

\section{Dependencies - Which dependencies?} % (fold)
\label{sec:dependencies_which_dependencies}
The examples from the last section were special, as the projects had no \emph{Execution Dependencies}. They had only \emph{Configuration Dependencies}. Here is an example where this is different:

\subsection{Execution Dependencies} % (fold)
\label{sub:execution_time_dependencies}

\subsubsection{Dependencies and Execution Order} % (fold)
\label{ssub:dependencies_and_execution_order}

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- messages
  F- gradlesettings
  D- consumer
    F- gradlefile
  D- producer
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/firstMessages/messages/gradlesettings}
\end{minipage}

\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/firstMessages/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/firstMessages/messages/producer/gradlefile}
\outputInputGradle[userguide/multiproject/dependencies/firstMessages/messages]{../../../build/tutorial-output/multiprojectFirstMessages.out}
This did not work out. If nothing else is defined, Gradle executes the task in alphanumeric order. Therefore \texttt{:consumer:action} is executed before \texttt{:producer:action}. Let's try to solve this with a hack and rename the producer project to \texttt{aProducer}.

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- messages
  F- gradlesettings
  D- aProducer
    F- gradlefile
  D- consumer
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesHack/messages/gradlesettings}
\end{minipage}

\codeGradleFile[aProducer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesHack/messages/aProducer/gradlefile}
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesHack/messages/consumer/gradlefile}
\outputInputGradle[userguide/multiproject/dependencies/messagesHack/messages]{../../../build/tutorial-output/multiprojectMessagesHack.out}
Now we take the air out of this hack. We simply switch to the \texttt{consumer} dir and execute the build.
\outputInputGradle[userguide/multiproject/dependencies/messagesHack/messages/consumer]{../../../build/tutorial-output/multiprojectMessagesHackBroken.out}
For Gradle the two \texttt{action} tasks are just not related. If you execute the build from the \texttt{messages} project Gradle executes them both because they have the same name and they are down the hierarchy. In the last example only one \texttt{action} was down the hierarchy and therefore it was the only task that got executed. We need something better than this hack.
% subsubsection dependencies_and_execution_order (end)
\subsubsection{Declaring Dependencies} % (fold)
\label{ssub:declaring_dependencies}

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- messages
  F- gradlesettings
  D- consumer
    F- gradlefile
  D- producer
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesWithDependencies/messages/gradlesettings}
\end{minipage}

\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesWithDependencies/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesWithDependencies/messages/producer/gradlefile}
\outputInputGradle[userguide/multiproject/dependencies/messagesHack/messages]{../../../build/tutorial-output/multiprojectMessagesDependencies.out}
\outputInputGradle[userguide/multiproject/dependencies/messagesHack/messages/consumer]{../../../build/tutorial-output/multiprojectMessagesDependenciesSubBuild.out}
We have now declared that the \texttt{consumer} project has an \emph{execution dependency} on the \texttt{producer} project. For Gradle declaring \emph{execution dependencies} between \emph{projects} is syntactic sugar. Under the hood Gradle creates task dependencies out of them. You can also create cross project tasks dependencies manually by using the absolute path of the tasks. 
% subsubsection declaring_dependencies (end)

\subsubsection{The Nature of Project Dependencies} % (fold)
\label{ssub:the_nature_of_project_dependencies}
Let's change the naming of our tasks and execute the build.
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesDifferentTaskNames/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesDifferentTaskNames/messages/producer/gradlefile}
\outputInputGradle[userguide/multiproject/dependencies/messagesDifferentTaskNames/messages/consumer]{../../../build/tutorial-output/multiprojectMessagesDifferentTaskNames.out}
Uhps. Why does this not work? The \texttt{dependsOn} command is created for projects with a common lifecycle. Provided you have two Java projects were one depends on the other. If you trigger a compile for for the dependent project you don't want that \emph{all} tasks of the other project get executed. Therefore a \texttt{dependsOn} creates dependencies between tasks with equal names. To deal with the scenario above you would do the following:
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesTaskDependencies/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesTaskDependencies/messages/producer/gradlefile}
\outputInputGradle[userguide/multiproject/dependencies/messagesTaskDependencies/messages/consumer]{../../../build/tutorial-output/multiprojectMessagesTaskDependencies.out}
% subsubsection the_nature_of_project_dependencies (end)
% subsection execution_time_dependencies (end)

\subsection{Configuration Time Dependencies} % (fold)
\label{sub:configuration_time_dependencies}
Let's have one more example with our producer-consumer build before we enter \emph{Java} land. We add a property to the producer project and create now a configuration time dependency from consumer on producer. 
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependenciesBroken/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependenciesBroken/messages/producer/gradlefile}
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesConfigDependenciesBroken.out}
The default \emph{evaluation} order of the projects is alphanumeric (for the same nesting level). Therefore the \texttt{consumer} project is evaluated before the \texttt{producer} project and the \texttt{key} value of the \texttt{producer} is set \emph{after} it is read by the \texttt{consumer} project. Gradle offers a solution for this. 
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependencies/messages/consumer/gradlefile}
\outputInputGradle[userguide/multiproject/dependencies/messagesConfigDependencies/messages/consumer]{../../../build/tutorial-output/multiprojectMessagesConfigDependencies.out}
The command \texttt{evaluationDependsOn} triggers the evaluation of \texttt{producer} \emph{before} \texttt{consumer} is evaluated.
The example is a bit contrived for the sake of showing the mechanism. In \emph{this} case there would be an easier solution by reading the key property at execution time.
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependenciesAltSolution/messages/consumer/gradlefile}
\outputInputGradle[userguide/multiproject/dependencies/messagesConfigDependencies/messages/consumer]{../../../build/tutorial-output/multiprojectMessagesConfigDependenciesAltSolution.out}
Configuration dependencies are very different to execution dependencies. Configuration dependencies are between projects whereas execution dependencies are always resolved to task dependencies. Another difference is that always all projects are configured, even when you start the build from a subproject. The default configuration order is top down, which is usually what is needed. 

On the same nesting level the configuration order depends on the alphanumeric position. The most common use case is to have multi-project builds that share a common lifecycle (e.g. all projects use the Java plugin). If you declare with \texttt{dependsOn} a \emph{execution dependency} between different projects, the default behavior of this method is to create also a \emph{configuration} dependency between the two projects. Therefore it is likely that you don't have to define configuration dependencies explicitly. 
% subsection configuration_time_dependencies (end)

\subsection{Real Life examples} % (fold)
\label{sub:real_life_examples}
Gradles multi-project features are driven by real life use cases. The first example for describing such a use case, consists of two webapplication projects and a parent project that creates a distribution out of them.\footnote{The real use case we had, was using \url{http://lucene.apache.org/solr}, where you need a separate war for each index your are accessing. That was one reason why we have created a distribution of webapps. The Resin servlet container allows us, to let such a distribution point to a base installation of the servlet container.} For the example we use only one build script and do \emph{cross project configuration}.
\begin{Verbatim}[frame=single,label=Project Tree]
D- webDist
  F- gradlesettings
  F- gradlefile
  D- date
    F- src/main/java/org/gradle/sample/DateServlet.java
  D- hello
    F- src/main/java/org/gradle/sample/HelloServlet.java
\end{Verbatim}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/webDist/gradlesettings}
\codeGradleFile[webDist - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/webdist/gradlefile}
We have an interesting set of dependencies. Obviously the \texttt{date} and \texttt{hello} task have a \emph{configuration} dependency on \texttt{webDist}, as all the build logic for the webapp projects is injected by \texttt{webDist}. The \emph{execution} dependency is in the other direction, as \texttt{webDist} depends on the build artifacts of \texttt{date} and \texttt{hello}. There is even a third dependency. \texttt{webDist} has a \emph{configuration} dependency on \texttt{date} and \texttt{hello} because it needs to know the \texttt{archivePath}. But it asks for this information at \emph{execution time}. Therefore we have no circular dependency.

Such and other dependency patterns are daily bread in the problem space of multi-project builds. If a build system does not support such patterns, you either can't solve your problem or you need to do ugly hacks which are hard to maintain and massively afflict your productivity as a build master.

There is one more thing to note from the current example. We have used the command \texttt{dependOnChildren()}. It is a convenience method and calls the \texttt{dependsOn} method of the parent project for every child project (not every sub project). It declares a \texttt{execution} dependency of \texttt{webDist} on \texttt{date} and \texttt{hello}.

Another use case would be a situation where the subprojects have a configuration \emph{and} execution dependency on the parent project. This is the case when the parent project does configuration injection into its subprojects, and additionally produces something at execution time that is needed by its child projects (e.g. code generation). In this case the parent project would call the \texttt{childrenDependOnMe} method to create an execution dependency for the child projects. We might add an example for this in a future version of the userguide.
% subsection real_life_examples (end)
% section dependencies_what_dependencies_ (end)
\section{Project Jar Dependencies} % (fold)
\label{sec:project_jar_dependencies}
What if one projects needs the jar produced by another project in its compile path. And not just the jar but also the transitive dependencies of this jar. Obviously this is a very common use case for Java multi-project builds. 

If you come from Maven land you might be perfectly happy with this. If you come from Ivy land your are used to have more fine grained control if needed. 



% section project_jar_dependencies (end) 
% chapter multi_project_builds (end)


