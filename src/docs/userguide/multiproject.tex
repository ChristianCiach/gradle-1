\chapter{Multi-project builds} % (fold)
\label{cha:multi_project_builds}

The powerful support for multi-project builds is one of Gradles unique selling points. This topic is also the intellectually most challenging. After all, the problem space of multi-project builds is a complex beast. Gradle has taken up this challenge. 
\section{Cross Project Configuration} % (fold)
\label{sec:cross_project_configuration}
Lets' start with a very simple multi-project build. After all Gradle is a general purpose build tool at its core. So the projects don't have to be java projects. Our first examples are about marine life. 

\subsection{Defining Common Behavior} % (fold)
\label{sub:defining_common_behavior}

We have the following project tree\footnote{F means File and D means Directory}. 

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/firstExample/water/gradlesettings}
\end{minipage}

\noindent And where is the build script for the bluewhale project? In Gradle build scripts are optional. Obviously for a single project build, a project without a build script doesn't make much sense. For multiproject builds the situation is different. Let's look at the build script for the water project and execute it.:
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/firstExample/water/gradlefile}
\outputInput{../../../build/tutorial-output/multiprojectFirstExample.out}
Gradle allows you to access any project of the multi-project build from any build script. The Project API provides a method called project, which takes a path as an argument and returns the project object for this path. The capability to configure a project build from any build script we call \emph{Configuration Injection}.

We are not that happy with the build script of the water project. It is inconvenient to add the task explicitly to every project. We can do better. Let's first add another project called \emph{krill} to our multi-project build.
Project layout

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
  D- krill	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/addKrill/water/gradlesettings}
\end{minipage}

\noindent Now we rewrite the water build script and boil it down to a single line.
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/addKrill/water/gradlefile}
\outputInput{../../../build/tutorial-output/multiprojectAddKrill.out}
Is this cool or is this cool? And how does this work? The Project API provides a property \texttt{allprojects} which returns a list with the current project and all its subprojects underneath it. Then we use Groovys spread dot operator, which calls a method for all members of a list. You could also do iteration via \texttt{allprojects.each}, but that would be more verbose.

\begin{graybox}
Other build systems use inheritance as the primary means for defining common behavior. We also offer inheritance for projects as you will see later. But Gradle uses \texttt{Configuration Injection} as the usual way of defining common behavior. We think it provides a very powerful and flexible way of configuring multiproject builds.	
\end{graybox}
% subsection defining_common_behavior (end)
% section cross_project_configuration (end)

\section{Subproject Configuration} % (fold)
\label{sec:subproject_configuration}
\noindent The Project API also provides a property for accessing the subprojects only. 

\subsection{Defining Common Behavior} % (fold)
\label{sub:defining_common_behavior}
\codeGradleFile{../../../build/distributions/exploded/samples/userguide/multiproject/useSubprojects/water/gradlefile}
\outputInput{../../../build/tutorial-output/multiprojectUseSubprojects.out}
% subsection defining_common_behavior (end)

\subsection{Adding Specific Behavior} % (fold)
\label{sub:adding_specific_behavior}
You can add specific behavior on top of the common behavior. Usually we put the project specific behavior in the build script of the project where we want to apply this specific behavior. But as we have already seen, we don't have to do it this way. We could add project specific behavior for the bluewhale project like this:
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/subProjectsAddFromTop/water/gradlefile}
\outputInput{../../../build/tutorial-output/multiprojectSubProjectsAddFromTop.out}
As we have said, we usually prefer to put project specific behavior into the build script of this project. Let's refactor and also add some project specific behavior to the krill project.

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
    F- gradlefile
  D- krill
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/gradlesettings}
\end{minipage}

\codeGradleFile[bluewhale - ]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/bluewhale/gradlefile}
\codeGradleFile[krill - ]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/krill/gradlefile}
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/spreadSpecifics/water/gradlefile}
\outputInput{../../../build/tutorial-output/multiprojectSpreadSpecifics.out}
% subsection adding_specific_behavior (end)
\subsection{Project Filtering} % (fold)
\label{sub:project_filtering}
To show some more of the power of \emph{Configuration Injection}, lets' add another project called tropicalFish and add more behavior to the build via the build script of the water project.

\subsubsection{Filtering By Name} % (fold)
\label{ssub:filtering_by_name}

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
    F- gradlefile
  D- krill
    F- gradlefile
  D- tropicalFish	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/addTropical/water/gradlesettings}
\end{minipage}

\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/addTropical/water/gradlefile}
\outputInput{../../../build/tutorial-output/multiprojectAddTropical.out}
% subsubsection filtering_by_name (end)
\subsubsection{Filtering By Properties} % (fold)
\label{ssub:filtering_by_properties}

Using the projectname for filtering is one option. Using dynamic project properties is another.
Project layout

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- water
  F- gradlefile
  F- gradlesettings
  D- bluewhale
    F- gradlefile
  D- krill
    F- gradlefile
  D- tropicalFish
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/gradlesettings}
\end{minipage}

\codeGradleFile[bluewhale - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/bluewhale/gradlefile}
\codeGradleFile[krill - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/krill/gradlefile}
\codeGradleFile[tropicalFish - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/tropicalFish/gradlefile}
\codeGradleFile[water - ]{../../../build/distributions/exploded/samples/userguide/multiproject/tropicalWithProperties/water/gradlefile}
\outputInput{../../../build/tutorial-output/multiprojectTropicalWithProperties.out}
% subsubsection filtering_by_properties (end)
% subsection project_filtering (end)
% section subproject_configuration (end)

\section{Execution rules for multi-project builds} % (fold)
\label{sec:execution_rules_for_multi_project_builds}
We have typed in the root project dir \texttt{gradle hello} and things behaved in an intuitive way. All the \texttt{hello} of the different projects were executed. Let's switch to the \texttt{bluewhale} dir and see what happens if we execute Gradle from there. 
\outputInputGradle[current dir: water/bluewhale]{../../../build/tutorial-output/multiprojectSubBuild.out}
The basic rule behind Gradles behavior is simple. Gradle looks down the hierarchy starting with the \emph{current dir} for tasks with the name \texttt{hello} an executes them. One thing is very important to note. Gradle \emph{always} evaluates every project of the multi-project build and creates all existing task objects. Then, according to the task names you have passed as an argument and the current dir, Gradle filters the tasks which should be executed. Because of Gradles \emph{Cross Project Configuration} \emph{every} project has to be evaluated before \emph{any} task gets executed. We will have a closer look at this in the next section. Before we will have our last marine example. Let's add a task to \texttt{bluewhale} and \texttt{krill}.
\codeGradleFile[bluewhale - ]{../../../build/distributions/exploded/samples/userguide/multiproject/partialTasks/water/bluewhale/gradlefile}
\codeGradleFile[krill - ]{../../../build/distributions/exploded/samples/userguide/multiproject/partialTasks/water/krill/gradlefile}
\outputInputGradle[current dir: water]{../../../build/tutorial-output/multiprojectPartialTasks.out}
Here the output without the \texttt{-q} option
\outputInputGradle[current dir: water]{../../../build/tutorial-output/multiprojectPartialTasksNotQuiet.out}
The build is executed from the \texttt{water} project. Neither \texttt{water} nor \texttt{tropicalFish} have a task with the name \texttt{distanceToIceberg}. Gradle does not care. The simple rule mentioned already above is: Execute all tasks down the hierarchy which have this name. Only complain if there is no such task!
% section execution_rules_for_multi_project_builds (end)

\section{Dependencies - Which dependencies?} % (fold)
\label{sec:dependencies_which_dependencies_}
The example from the last section was special, as the projects had no \emph{Execution Time Dependencies}. They had only \emph{Configuration Time Dependencies}. Here is an example where this is different:

\subsection{Execution Time Dependencies} % (fold)
\label{sub:execution_time_dependencies}

\subsubsection{Dependencies and Execution Order} % (fold)
\label{ssub:dependencies_and_execution_order}

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- messages
  F- gradlesettings
  D- consumer
    F- gradlefile
  D- producer
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/firstMessages/messages/gradlesettings}
\end{minipage}

\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/firstMessages/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/firstMessages/messages/producer/gradlefile}
\outputInputGradle[messages]{../../../build/tutorial-output/multiprojectFirstMessages.out}
This did not work out. If nothing else is defined, Gradle executes the task in alphanumeric order. Therefore \texttt{:consumer:action} is executed before \texttt{:producer:action}. Let's try to solve this with a hack and rename the producer project to \texttt{aProducer}.

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- messages
  F- gradlesettings
  D- aProducer
    F- gradlefile
  D- consumer
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesHack/messages/gradlesettings}
\end{minipage}

\codeGradleFile[aProducer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesHack/messages/aProducer/gradlefile}
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesHack/messages/consumer/gradlefile}
\outputInputGradle[messages]{../../../build/tutorial-output/multiprojectMessagesHack.out}
Now we take the air out of this hack. We simply switch to the \texttt{consumer} dir and execute the build.
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesHackBroken.out}
For Gradle the two \texttt{action} tasks are just not related. If you execute the build from the \texttt{messages} project Gradle executes them both because they have the same name and they are down the hierarchy. In the last example only one \texttt{action} was down the hierarchy and therefore it was the only task that got executed. We need something better than this hack.
% subsubsection dependencies_and_execution_order (end)
\subsubsection{Declaring Dependencies} % (fold)
\label{ssub:declaring_dependencies}

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- messages
  F- gradlesettings
  D- consumer
    F- gradlefile
  D- producer
    F- gradlefile	
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesWithDependencies/messages/gradlesettings}
\end{minipage}

\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesWithDependencies/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesWithDependencies/messages/producer/gradlefile}
\outputInputGradle[messages]{../../../build/tutorial-output/multiprojectMessagesDependencies.out}
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesDependenciesSubBuild.out}
We have now declared that the \texttt{consumer} project has an \emph{execution time dependency} on the \texttt{producer} project. For Gradle declaring \emph{execution time dependencies} between \emph{projects} is syntactic sugar. Under the hood Gradle creates task dependencies out of them. You can also create cross project tasks dependencies manually by using the absolute path. 
% subsubsection declaring_dependencies (end)
\subsubsection{The Nature of Project Dependencies} % (fold)
\label{ssub:the_nature_of_project_dependencies}
Let's change the naming of our tasks and execute the build.
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesDifferentTaskNames/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesDifferentTaskNames/messages/producer/gradlefile}
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesDifferentTaskNames.out}
Uhps. Why does this not work? The \texttt{dependsOn} command is created for projects with a common lifecycle. Provided you have two Java projects were one depends on the other. If you trigger a compile for for the dependent project you don't want that \emph{all} tasks of the other project get executed. Therefore a \texttt{dependsOn} creates dependencies between tasks with equal names. To deal with the scenario above you would do the following:
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesTaskDependencies/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesTaskDependencies/messages/producer/gradlefile}
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesTaskDependencies.out}
% subsubsection the_nature_of_project_dependencies (end)
% subsection execution_time_dependencies (end)

\subsection{Configuration Time Dependencies} % (fold)
\label{sub:configuration_time_dependencies}
Let's have one more example with our producer-consumer build before we enter \emph{Java} land. We add a property to the producer project and create now a configuration time dependency from consumer on producer. 
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependenciesBroken/messages/consumer/gradlefile}
\codeGradleFile[producer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependenciesBroken/messages/producer/gradlefile}
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesConfigDependenciesBroken.out}
The default \emph{evaluation} order of the projects is alphanumeric (for the same nesting level). Therefore the \texttt{consumer} project is evaluated before the \texttt{producer} project and the \texttt{key} value of the \texttt{producer} is set \emph{after} it is read by the \texttt{consumer} project. Gradle offers a solution for this. 
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependencies/messages/consumer/gradlefile}
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesConfigDependencies.out}
The command \texttt{evaluationDependsOn} triggers the evaluation of \texttt{producer} \emph{before} \texttt{consumer} is evaluated.
The example is a bit contrived for the sake of showing the mechanism. In \emph{this} case there would be an easier solution by reading the key property at execution time.
\codeGradleFile[consumer - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/messagesConfigDependenciesAltSolution/messages/consumer/gradlefile}
\outputInputGradle[consumer]{../../../build/tutorial-output/multiprojectMessagesConfigDependenciesAltSolution.out}
% subsection configuration_time_dependencies (end)

\subsection{Real Life examples} % (fold)
\label{sub:real_life_examples}
Gradles multi-project features are driven by real life use cases. The first example consists of two webapplication projects and a parent project that creates a distribution out of them.\footnote{The real use case we had, was using \url{http://lucene.apache.org/solr}, where you need a separate war for each index your are accessing. That was one reason why we have created a distribution of webapps. The Resin servlet container allows us, to let such a distribution point to a base installation of the servlet container.} For the example we use only one build script and do \emph{cross project configuration}.

\begin{minipage}[t]{7cm}
\begin{Verbatim}[frame=single,label=Project Tree]
D- webDist
  F- gradlesettings
  F- gradlefile
  D- date
    F- src/main/java/org/gradle/sample/DateServlet.java
  D- hello
    F- src/main/java/org/gradle/sample/HelloServlet.java
\end{Verbatim}
\end{minipage}	
\begin{minipage}[t]{9cm}
\VerbatimInput[frame=single,label=gradlesettings]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/webDist/gradlesettings}
\end{minipage}
\codeGradleFile[webDist - ]{../../../build/distributions/exploded/samples/userguide/multiproject/dependencies/webdist/gradlefile}
We have an interesting set of dependencies. Obviously the \texttt{date} and \texttt{hello} have a \emph{configuration} dependency on \texttt{webDist} as all the build logic for the webapps is by \texttt{webDist}. The \texttt{execution} dependency is in the other direction, as \texttt{webDist} depends on the build artifacts of \texttt{date} and \texttt{hello}. There is even a third dependency. \texttt{webDist} has a \emph{configuration} dependency on \texttt{date} and \texttt{hello} because it needs to know the \texttt{archivePath}. But it asks for this information at \emph{execution time}. Therefore we have no circular dependency.
Such and other dependency patterns are daily bread in the problem space of multi-project builds. If a build system does not support such patterns, you either can't solve your problem or you need to do ugly hacks which are hard to maintain and massively afflict your productivity as a build master.
There is one more thing to note from the current example. We have used the command \texttt{dependOnChildren()}. It is a convenient method and calls \texttt{dependsOn} in the parent project for every child project (not every sub project). It declares a \texttt{execution} dependency of \texttt{webDist} on \texttt{date} and \texttt{hello}. 
% subsection real_life_examples (end)
% section dependencies_what_dependencies_ (end)
\section{Project Jar Dependencies} % (fold)
\label{sec:project_jar_dependencies}
What if one projects needs the jar produced by another project in its compile path. And not just the jar but also the transitive dependencies of this jar. Obviously this is a very common use case for Java multi-project builds. 

If you come from Maven land you might be perfectly happy with this. If you come from Ivy land your are used to have more fine grained control if needed. 



% section project_jar_dependencies (end) 
% chapter multi_project_builds (end)


