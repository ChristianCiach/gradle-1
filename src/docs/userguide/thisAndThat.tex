%!TEX root = userguide.tex
\chapter{The 'This And That' Tutorial} % (fold)
\label{cha:the_this_and_that_tutorial}
\section{Skipping Tasks}
Gradle offers multiple ways to skip the execution of a task.
\codeInput{../../samples/userguide/tutorial/skipProperties/build.gradle}
\outputInputTutorial{skipProperties}
The \texttt{-D} option of the \texttt{gradle} command has the same effect as the \texttt{-D} option of the \texttt{java} command. This way you can set system properties of the JVM that runs Gradle. You can add one ore more \emph{skip properties} to any existing task. If the corresponding system property is set to any value/footnote{The statement \texttt{-Dprop} sets the property to empty string, thus you don't need to type more to skip a task.} except false (case does not matter), the actions of the task don't get executed. But often you don't even need to set the skip properties. If you set a system property according to the pattern \texttt{skip.\emph{taskname}}, the actions of this task don't get executed.
\codeInput{../../samples/userguide/tutorial/autoskip/build.gradle}
\outputInputTutorial{autoskip}
If you want tasks to be skipped, that depends on a skipped task, you have to declare this explicitly via the skip properties
%
\codeInput{../../samples/userguide/tutorial/autoskipDepends/build.gradle}
\outputInputTutorial{autoskipDepends}
If the rules for skipping a task can't be expressed with a simple property, you can use the \texttt{StopExecutionException}\footnote{The fully qualified name is \texttt{org.gradle.api.tasks.StopExecutionException}}. If this exception is thrown by an action, the further execution of this action as well as the execution of any following action of this task is skipped. The build continues with executing the next task.
%
\codeInput{../../samples/userguide/tutorial/stopExecutionException/build.gradle}
\outputInputTutorial{stopExecutionException}
This feature is helpful if you work with tasks provided by Gradle. It allows you to add \emph{conditional} execution of the built-in actions of such a task. 

You might be wondering why there is neither an import for the \texttt{StopExecutionException} nor do we access it via its fully qualified name. The reason is, that Gradle adds a set of default imports to your script. These imports are customizable (see Appendix \ref{ide_support}).

Every task has also a \texttt{enabled} flag which defaults to \texttt{true}. Setting it to false prevents the execution of any of the tasks actions.
\codeInput{../../samples/userguide/tutorial/disableTask/build.gradle}
\outputInputTutorial{disableTask}

\section{Obtaining Information About Your Build}
Gradle provides several ways you can find out many details of your build. This can be useful for understanding the structure and
dependencies of your build, and for debugging problems. Firstly, Gradle provides several command-line options which show
particular details of your build. And secondly, Gradle provides a \texttt{project-reports} plugin, which adds tasks to
generate reports about your build.

Running \texttt{gradle --tasks} gives you a list of the tasks which make up the build, broken down by project. This
report shows the default tasks, if any, of each project, and the description and dependencies of each task. Below is an example
of this report:
\outputInputTutorial{taskListReport}

Running \texttt{gradle --dependencies} gives you a list of the dependencies of the build, broken down by project. This report
shows the configurations of each project. For each configuration, the direct and transitive dependencies of that configuration are shown.
Below is an example of this report:
\outputInputTutorial{dependencyListReport}

Running \texttt{gradle --properties} gives you a list of the properties of each project in the build. Below is an
example of this report:
\outputInputTutorial{propertyListReport}

Finally, you can use the \texttt{project-reports} plugin to add a number of reporting tasks to your project.

\section{Directory Creation} % (fold)
\label{sec:directory_creation}
There is a common situation, that multiple tasks depend on the existence of a directory. Of course you can deal with this by adding a \texttt{mkdir} to the beginning of those tasks. But this is kind of bloated. 
There is a better solution (works only if the tasks that need the directory have a \emph{dependsOn} relationship):
\codeInput{../../samples/userguide/tutorial/makeDirectory/build.gradle}
\outputInputTutorial{makeDirectory}
But Gradle offers you also \emph{Directory Tasks} to deal with this.
\codeInput{../../samples/userguide/tutorial/directoryTask/build.gradle}
\outputInputTutorial{directoryTask}
A \emph{Directory Task} is a simple task which name is a relative path to the project dir\footnote{The notation \texttt{dir('/somepath')} is a convenience method for \texttt{createTask('somepath', type: Directory)}}. During the execution phase the directory corresponding to this path gets created if it does not exist yet. Another interesting thing to note in this example, is that you can also pass tasks objects to the dependsOn declaration of a task.
% section directory_creation (end)

\section{Gradle Properties and System Properties} % (fold)
\label{sec:gradle_properties_and_system_properties}
Gradle offers a variety of ways to add properties to your build. With the \texttt{-D} command line option you can pass a system property to the JVM which runs Gradle. 

There is also the possibility to directly add properties to your project objects. You can place a \texttt{gradle.properties} file either in the Gradle user home dir (defaults to \texttt{\emph{USER\_HOME}/.gradle}) or in your project dir. For multiproject builds you can place \texttt{gradle.properties} files in any subproject. The properties of the \texttt{gradle.properties} can be accessed via the project object. The properties file in the the user's home directory has precedence over property files in the project directories. 

You can also add properties directly to your project object via the \texttt{-P} command line option. For more exotic use cases you can even pass properties \emph{directly} to the project object via system and environment properties. For example if you run a build on a continuous integration server where you have no admin rights for the \emph{machine}. Your build script needs properties which values should not be seen by others. Therefore you can't use the \texttt{-P} option. In this case you can add an environment property in the project adminstration section (invisible to normal users).\footnote{\emph{Teamcity} or \emph{Bamboo} are for example CI servers which offer this functionality} If the environment property follows the pattern \texttt{ORG\_GRADLE\_PROJECT\_yourProperty=somevalue}, \texttt{yourProperty} is added to your project object. If in the future CI servers support Gradle directly, they might start Gradle via its main method. Therefore we already support the same mechanism for system properties. The only difference is the prefix, which is \texttt{org.gradle.project.}.

With the \texttt{gradle.properties} files you can also set system properties. If a property in such a file has the prefix \texttt{systemProp.} the property and its value are added to the system properties (without the prefix).
\codeInput{../../samples/userguide/tutorial/properties/gradle.properties}
\codeInput{../../samples/userguide/tutorial/properties/build.gradle}
\outputInputTutorial{properties}
\subsection{Checking for Project Properties} % (fold)
\label{sub:checking_for_project_properties}
You can access a project property in your build script simply by using it name as you would use a variable. In case this property does not exists, an exception is thrown and the build fails. If your build script relies on optional properties the user might set for example in a gradle.properties file, you need to check for existence before you can access them. You can do this by using the method \texttt{hasProperty('propertyName')} which returns \texttt{true} or \texttt{false}.
% subsection checking_for_project_properties (end)
% section gradle_properties_and_system_properties (end)
% chapter the_this_and_that_tutorial (end)

\section{Accessing the web via a proxy} % (fold)
\label{sec:accessing_the_web_via_a_proxy}
Setting a proxy for web access (for example for downloading dependencies) is easy. Gradle does not need to provide special functionality for this. The JVM can be instructed to go via proxy by setting certain system properties. You could set this system properties directly in your build script with \texttt{System.properties['proxy.proxyUser'] = 'userid'}. An arguably nicer way is shown in section \ref{sec:gradle_properties_and_system_properties}. Your gradle.properties file could look like this:
\begin{Verbatim}
systemProp.http.proxyHost=http://www.somehost.org
systemProp.http.proxyPort=8080
systemProp.http.proxyUser=userid
systemProp.http.proxyPassword=password	
\end{Verbatim}
We could not find a good overview for all possible proxy settings. The best we can offer are the constants in a file from the ant project. Here a \href{http://svn.apache.org/viewvc/ant/core/trunk/src/main/org/apache/tools/ant/util/ProxySetup.java?view=markup&pathrev=556977}{link} to the svn view. If anyone knows a better overview please let us know via the mailing list.  
% section accessing_the_web_via_a_proxy (end)

\section{Caching} % (fold)
\label{sec:caching}
To improve the responsiveness Gradle caches the compiled build script by default. The first time you run a build for a project, Gradle creates a \texttt{.gradle} directory in which it puts the compiled build script. The next time you run this build, Gradle uses the compiled build script, if the timestamp of the compiled script is newer than the timestamp of the actual build script. Otherwise the build script gets compiled and the new version is stored in the cache. If you run Gradle with the \texttt{-x} option, any existing cache is ignored and the build script is compiled and executed on the fly. If you run Gradle with the \texttt{-r} option, the build script is always compiled and stored in the cache. That way you can always rebuild the cache if for example the timestamps for some reasons don't reflect that the build script needs to be recomiled. 
% section caching (end)

\section{Configuring Arbitrary Objects} % (fold)
\label{sec:configuring_arbitrary_objects}
You can configure arbitrary objects in the following very readable way.
\codeInput{../../samples/userguide/tutorial/configureObject/build.gradle}
\outputInputTutorial{configureObject}
% section configuring_arbitrary_objects (end)


